<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>speclj.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Speclj</span> <span class="project-version">3.4.2</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>speclj</span></div></div></li><li class="depth-2 branch"><a href="speclj.cli.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cli</span></div></a></li><li class="depth-2 branch"><a href="speclj.components.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>components</span></div></a></li><li class="depth-2 branch"><a href="speclj.config.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>config</span></div></a></li><li class="depth-2 branch current"><a href="speclj.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="speclj.main.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>main</span></div></a></li><li class="depth-2 branch"><a href="speclj.platform.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>platform</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>report</span></div></div></li><li class="depth-3 branch"><a href="speclj.report.clojure-test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure-test</span></div></a></li><li class="depth-3 branch"><a href="speclj.report.documentation.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>documentation</span></div></a></li><li class="depth-3 branch"><a href="speclj.report.progress.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>progress</span></div></a></li><li class="depth-3"><a href="speclj.report.silent.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>silent</span></div></a></li><li class="depth-2 branch"><a href="speclj.reporting.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>reporting</span></div></a></li><li class="depth-2 branch"><a href="speclj.results.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>results</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>run</span></div></div></li><li class="depth-3 branch"><a href="speclj.run.standard.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>standard</span></div></a></li><li class="depth-3"><a href="speclj.run.vigilant.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vigilant</span></div></a></li><li class="depth-2 branch"><a href="speclj.running.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>running</span></div></a></li><li class="depth-2 branch"><a href="speclj.stub.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stub</span></div></a></li><li class="depth-2"><a href="speclj.tags.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tags</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="speclj.core.html#var--fail"><div class="inner"><span>-fail</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-after"><div class="inner"><span>after</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-after-all"><div class="inner"><span>after-all</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-around"><div class="inner"><span>around</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-around-all"><div class="inner"><span>around-all</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-before"><div class="inner"><span>before</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-before-all"><div class="inner"><span>before-all</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-cljs-munge"><div class="inner"><span>cljs-munge</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-context"><div class="inner"><span>context</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-describe"><div class="inner"><span>describe</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-focus-context"><div class="inner"><span>focus-context</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-focus-describe"><div class="inner"><span>focus-describe</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-focus-it"><div class="inner"><span>focus-it</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-it"><div class="inner"><span>it</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-pending"><div class="inner"><span>pending</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-run-specs"><div class="inner"><span>run-specs</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should"><div class="inner"><span>should</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-be"><div class="inner"><span>should-be</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-be-a"><div class="inner"><span>should-be-a</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-be-nil"><div class="inner"><span>should-be-nil</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-be-same"><div class="inner"><span>should-be-same</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-contain"><div class="inner"><span>should-contain</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-end-with"><div class="inner"><span>should-end-with</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-fail"><div class="inner"><span>should-fail</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-have-count"><div class="inner"><span>should-have-count</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-have-invoked"><div class="inner"><span>should-have-invoked</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-invoke"><div class="inner"><span>should-invoke</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not"><div class="inner"><span>should-not</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not-be"><div class="inner"><span>should-not-be</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not-be-a"><div class="inner"><span>should-not-be-a</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not-be-nil"><div class="inner"><span>should-not-be-nil</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not-be-same"><div class="inner"><span>should-not-be-same</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not-contain"><div class="inner"><span>should-not-contain</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not-end-with"><div class="inner"><span>should-not-end-with</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not-have-count"><div class="inner"><span>should-not-have-count</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not-have-invoked"><div class="inner"><span>should-not-have-invoked</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not-invoke"><div class="inner"><span>should-not-invoke</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not-start-with"><div class="inner"><span>should-not-start-with</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not-throw"><div class="inner"><span>should-not-throw</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not.3D"><div class="inner"><span>should-not=</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-not.3D.3D"><div class="inner"><span>should-not==</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-start-with"><div class="inner"><span>should-start-with</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should-throw"><div class="inner"><span>should-throw</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should.3C"><div class="inner"><span>should&lt;</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should.3C.3D"><div class="inner"><span>should&lt;=</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should.3D"><div class="inner"><span>should=</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should.3D.3D"><div class="inner"><span>should==</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should.3E"><div class="inner"><span>should&gt;</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-should.3E.3D"><div class="inner"><span>should&gt;=</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-stub"><div class="inner"><span>stub</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-tags"><div class="inner"><span>tags</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-with"><div class="inner"><span>with</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-with.21"><div class="inner"><span>with!</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-with-all"><div class="inner"><span>with-all</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-with-all.21"><div class="inner"><span>with-all!</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-with-stubs"><div class="inner"><span>with-stubs</span></div></a></li><li class="depth-1"><a href="speclj.core.html#var-xit"><div class="inner"><span>xit</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">speclj.core</h1><div class="doc"><pre class="plaintext">Speclj's API. It contains nothing but macros, so that it can be used
in both Clojure and ClojureScript.</pre></div><div class="public anchor" id="var--fail"><h3>-fail</h3><h4 class="type">macro</h4><div class="usage"><code>(-fail message)</code></div><div class="doc"><pre class="plaintext">Useful for making custom assertions.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L216">view source</a></div></div><div class="public anchor" id="var-after"><h3>after</h3><h4 class="type">macro</h4><div class="usage"><code>(after &amp; body)</code></div><div class="doc"><pre class="plaintext">Declares a function that is invoked after each characteristic in the containing describe scope is evaluated. The body
may consist of any forms, presumably ones that perform side effects.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L115">view source</a></div></div><div class="public anchor" id="var-after-all"><h3>after-all</h3><h4 class="type">macro</h4><div class="usage"><code>(after-all &amp; body)</code></div><div class="doc"><pre class="plaintext">Declares a function that is invoked once after all the characteristics in the containing describe scope have been
evaluated.  The body may consist of any forms, presumably ones that perform side effects.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L139">view source</a></div></div><div class="public anchor" id="var-around"><h3>around</h3><h4 class="type">macro</h4><div class="usage"><code>(around binding &amp; body)</code></div><div class="doc"><pre class="plaintext">Declares a function that will be invoked around each characteristic of the containing describe scope.
The characteristic will be passed in and the around function is responsible for invoking it.

(around [it] (binding [*out* new-out] (it)))

Note that if you have cleanup that must run, use a 'finally' block:

(around [it] (try (it) (finally :clean-up)))</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L121">view source</a></div></div><div class="public anchor" id="var-around-all"><h3>around-all</h3><h4 class="type">macro</h4><div class="usage"><code>(around-all context &amp; body)</code></div><div class="doc"><pre class="plaintext">Declares a function that is invoked once around all characteristics of the containing describe scope.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L145">view source</a></div></div><div class="public anchor" id="var-before"><h3>before</h3><h4 class="type">macro</h4><div class="usage"><code>(before &amp; body)</code></div><div class="doc"><pre class="plaintext">Declares a function that is invoked before each characteristic in the containing describe scope is evaluated. The body
may consist of any forms, presumably ones that perform side effects.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L109">view source</a></div></div><div class="public anchor" id="var-before-all"><h3>before-all</h3><h4 class="type">macro</h4><div class="usage"><code>(before-all &amp; body)</code></div><div class="doc"><pre class="plaintext">Declares a function that is invoked once before any characteristic in the containing describe scope is evaluated. The
body may consist of any forms, presumably ones that perform side effects.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L133">view source</a></div></div><div class="public anchor" id="var-cljs-munge"><h3>cljs-munge</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L150">view source</a></div></div><div class="public anchor" id="var-context"><h3>context</h3><h4 class="type">macro</h4><div class="usage"><code>(context name &amp; components)</code></div><div class="doc"><pre class="plaintext">Same as describe, but should be used to nest testing contexts inside the outer describe.
Contexts can be nested any number of times.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L95">view source</a></div></div><div class="public anchor" id="var-describe"><h3>describe</h3><h4 class="type">macro</h4><div class="usage"><code>(describe name &amp; components)</code></div><div class="doc"><pre class="plaintext">body =&gt; &amp; spec-components

Declares a new spec.  The body can contain any forms that evaluate to spec components (it, before, after, with ...).</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L80">view source</a></div></div><div class="public anchor" id="var-focus-context"><h3>focus-context</h3><h4 class="type">macro</h4><div class="usage"><code>(focus-context name &amp; components)</code></div><div class="doc"><pre class="plaintext">Same as 'context', but it is meant to facilitate temporary debugging.
Components defined with this macro will be fully executed along with any
other components thus defined, but all other sibling components defined
with 'context' will be ignored.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L101">view source</a></div></div><div class="public anchor" id="var-focus-describe"><h3>focus-describe</h3><h4 class="type">macro</h4><div class="usage"><code>(focus-describe name &amp; components)</code></div><div class="doc"><pre class="plaintext">Same as 'describe', but it is meant to facilitate temporary debugging.
Components defined with this macro will be fully executed along with any
other components thus defined, but all other sibling components defined
with 'describe' will be ignored.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L87">view source</a></div></div><div class="public anchor" id="var-focus-it"><h3>focus-it</h3><h4 class="type">macro</h4><div class="usage"><code>(focus-it name &amp; body)</code></div><div class="doc"><pre class="plaintext">Same as 'it', but it is meant to facilitate temporary debugging.
Characteristics defined with this macro will be executed along with any
other characteristics thus defined, but all other characteristic defined
with 'it' will be ignored.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L67">view source</a></div></div><div class="public anchor" id="var-it"><h3>it</h3><h4 class="type">macro</h4><div class="usage"><code>(it name &amp; body)</code></div><div class="doc"><pre class="plaintext">body =&gt; any forms, but should contain at least one assertion (should)

Declares a new characteristic (example in rspec).</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L55">view source</a></div></div><div class="public anchor" id="var-pending"><h3>pending</h3><h4 class="type">macro</h4><div class="usage"><code>(pending)</code><code>(pending message)</code></div><div class="doc"><pre class="plaintext">When added to a characteristic, it is marked as pending.  If a message is provided it will be printed
in the run report</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L615">view source</a></div></div><div class="public anchor" id="var-run-specs"><h3>run-specs</h3><h4 class="type">macro</h4><div class="usage"><code>(run-specs)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L834">view source</a></div></div><div class="public anchor" id="var-should"><h3>should</h3><h4 class="type">macro</h4><div class="usage"><code>(should form)</code></div><div class="doc"><pre class="plaintext">Asserts the truthy-ness of a form
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L226">view source</a></div></div><div class="public anchor" id="var-should-be"><h3>should-be</h3><h4 class="type">macro</h4><div class="usage"><code>(should-be f-form actual-form)</code></div><div class="doc"><pre class="plaintext">Asserts that a form satisfies a function.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L251">view source</a></div></div><div class="public anchor" id="var-should-be-a"><h3>should-be-a</h3><h4 class="type">macro</h4><div class="usage"><code>(should-be-a expected-type actual-form)</code></div><div class="doc"><pre class="plaintext">Asserts that the type of the given form derives from or equals the expected type
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L597">view source</a></div></div><div class="public anchor" id="var-should-be-nil"><h3>should-be-nil</h3><h4 class="type">macro</h4><div class="usage"><code>(should-be-nil form)</code></div><div class="doc"><pre class="plaintext">Asserts that the form evaluates to nil
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L286">view source</a></div></div><div class="public anchor" id="var-should-be-same"><h3>should-be-same</h3><h4 class="type">macro</h4><div class="usage"><code>(should-be-same expected-form actual-form)</code></div><div class="doc"><pre class="plaintext">Asserts that two forms evaluate to the same object, with the expected value as the first parameter.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L272">view source</a></div></div><div class="public anchor" id="var-should-contain"><h3>should-contain</h3><h4 class="type">macro</h4><div class="usage"><code>(should-contain expected actual)</code></div><div class="doc"><pre class="plaintext">Multi-purpose assertion of containment.  Works on strings, regular expressions, sequences, and maps.

(should-contain "foo" "foobar")            ; looks for sub-string
(should-contain #"hello.*" "hello, world") ; looks for regular expression
(should-contain :foo {:foo :bar})          ; looks for a key in a map
(should-contain 3 [1 2 3 4])               ; looks for an object in a collection</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L291">view source</a></div></div><div class="public anchor" id="var-should-end-with"><h3>should-end-with</h3><h4 class="type">macro</h4><div class="usage"><code>(should-end-with suffix whole)</code></div><div class="doc"><pre class="plaintext">Assertion of suffix in strings and sequences.

(should-end-with "foo" "foobar")            ; looks for string suffix
(should-end-with [1 2] [1 2 3 4])               ; looks for a subset at end of collection</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L442">view source</a></div></div><div class="public anchor" id="var-should-fail"><h3>should-fail</h3><h4 class="type">macro</h4><div class="usage"><code>(should-fail)</code><code>(should-fail message)</code></div><div class="doc"><pre class="plaintext">Forces a failure. An optional message may be passed in.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L544">view source</a></div></div><div class="public anchor" id="var-should-have-count"><h3>should-have-count</h3><h4 class="type">macro</h4><div class="usage"><code>(should-have-count expected coll)</code></div><div class="doc"><pre class="plaintext">Multi-purpose assertion on (count %). Works on strings, sequences, and maps.

(should-have-count 6 "foobar")
(should-have-count 2 [1 2]})
(should-have-count 1 {:foo :bar})
(should-have-count 0 [])
(should-have-count 0 nil)</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L338">view source</a></div></div><div class="public anchor" id="var-should-have-invoked"><h3>should-have-invoked</h3><h4 class="type">macro</h4><div class="usage"><code>(should-have-invoked name)</code><code>(should-have-invoked name options)</code></div><div class="doc"><pre class="plaintext">Checks for invocations of the specified stub.

Options:
  :times - the number of times the stub should have been invoked. nil means at least once. (default: nil)
  :with - a list of arguments that the stubs should have been invoked with.
    If not specified, anything goes.  Special expected arguments include:
     :* - matches anything
     a fn - matches when the actual is the same fn or calling fn with the actual argument returns true

Example:
(let [foo (stub :foo)]
  (should-have-invoked :foo {:with [1] :times 3}) ; fail
  (foo 1)
  (foo 2)
  (should-have-invoked :foo {:with [1] :times 3}) ; fail
  (should-have-invoked :foo {:with [1] :times 1}) ; pass
  (should-have-invoked :foo {:with [2] :times 1}) ; pass
  (should-have-invoked :foo {:times 3}) ; fail
  (should-have-invoked :foo {:times 2}) ; pass
  (should-have-invoked :foo {:times 1}) ; fail
  (should-have-invoked :foo {:with [1]}) ; pass
  (should-have-invoked :foo {:with [2]}) ; pass
  )</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L649">view source</a></div></div><div class="public anchor" id="var-should-invoke"><h3>should-invoke</h3><h4 class="type">macro</h4><div class="usage"><code>(should-invoke var options &amp; body)</code></div><div class="doc"><pre class="plaintext">Creates a stub, and binds it to the specified var, evaluates the body, and checks the invocations.

(should-invoke reverse {:with [1 2 3] :return []} (reverse [1 2 3]))

See stub and should-have-invoked for valid options.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L773">view source</a></div></div><div class="public anchor" id="var-should-not"><h3>should-not</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not form)</code></div><div class="doc"><pre class="plaintext">Asserts the falsy-ness of a form
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L233">view source</a></div></div><div class="public anchor" id="var-should-not-be"><h3>should-not-be</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not-be f-form actual-form)</code></div><div class="doc"><pre class="plaintext">Asserts that a form does not satisfy a function.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L258">view source</a></div></div><div class="public anchor" id="var-should-not-be-a"><h3>should-not-be-a</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not-be-a expected-type actual-form)</code></div><div class="doc"><pre class="plaintext">Asserts that the type of the given form does not derived from or equals the expected type
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L606">view source</a></div></div><div class="public anchor" id="var-should-not-be-nil"><h3>should-not-be-nil</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not-be-nil form)</code></div><div class="doc"><pre class="plaintext">Asserts that the form evaluates to a non-nil value
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L539">view source</a></div></div><div class="public anchor" id="var-should-not-be-same"><h3>should-not-be-same</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not-be-same expected-form actual-form)</code></div><div class="doc"><pre class="plaintext">Asserts that two forms evaluate to different objects, with the unexpected value as the first parameter.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L279">view source</a></div></div><div class="public anchor" id="var-should-not-contain"><h3>should-not-contain</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not-contain expected actual)</code></div><div class="doc"><pre class="plaintext">Multi-purpose assertion of non-containment.  See should-contain as an example of opposite behavior.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L317">view source</a></div></div><div class="public anchor" id="var-should-not-end-with"><h3>should-not-end-with</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not-end-with prefix whole)</code></div><div class="doc"><pre class="plaintext">The inverse of should-end-with.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L471">view source</a></div></div><div class="public anchor" id="var-should-not-have-count"><h3>should-not-have-count</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not-have-count expected coll)</code></div><div class="doc"><pre class="plaintext">Multi-purpose assertion on (not= (count %)). Works on strings, sequences, and maps.

(should-not-have-count 1 "foobar")
(should-not-have-count 1 [1 2]})
(should-not-have-count 42 {:foo :bar})
(should-not-have-count 1 [])
(should-not-have-count 1 nil)</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L357">view source</a></div></div><div class="public anchor" id="var-should-not-have-invoked"><h3>should-not-have-invoked</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not-have-invoked name)</code><code>(should-not-have-invoked name options)</code></div><div class="doc"><pre class="plaintext">Inverse of should-have-invoked.

Options:
  :times - the number of times the stub should not have been invoked. nil means never. (default: nil)
  :with - a list of arguments that the stubs should not have been invoked with.
    If not specified, anything goes. Special expected arguments include:
     :* - matches anything
     a fn - matches when the actual is the same fn or calling fn with the actual argument returns true

Example:
(let [foo (stub :foo)]
  (should-not-have-invoked :foo {:with [1] :times 3}) ; pass
  (foo 1)
  (should-not-have-invoked :foo {:with [1] :times 3}) ; pass
  (should-not-have-invoked :foo {:with [1] :times 1}) ; fail
  (should-not-have-invoked :foo {:times 3}) ; pass
  (should-not-have-invoked :foo {:times 1}) ; fail
  (should-not-have-invoked :foo {:with [1]}) ; fail
  )</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L706">view source</a></div></div><div class="public anchor" id="var-should-not-invoke"><h3>should-not-invoke</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not-invoke var options &amp; body)</code></div><div class="doc"><pre class="plaintext">Creates a stub, and binds it to the specified var, evaluates the body, and checks that is was NOT invoked.

(should-not-invoke reverse {:with [1 2 3] :return [] :times 2} (reverse [1 2 3])) ; pass
(should-not-invoke reverse {:with [1 2 3] :return []} (reverse [1 2 3])) ; fail

See stub and should-not-have-invoked for valid options.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L789">view source</a></div></div><div class="public anchor" id="var-should-not-start-with"><h3>should-not-start-with</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not-start-with prefix whole)</code></div><div class="doc"><pre class="plaintext">The inverse of should-start-with.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L421">view source</a></div></div><div class="public anchor" id="var-should-not-throw"><h3>should-not-throw</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not-throw form)</code></div><div class="doc"><pre class="plaintext">Asserts that nothing is thrown by the evaluation of a form.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L588">view source</a></div></div><div class="public anchor" id="var-should-not.3D"><h3>should-not=</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not= expected-form actual-form)</code></div><div class="doc"><pre class="plaintext">Asserts that two forms evaluate to unequal values, with the unexpected value as the first parameter.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L265">view source</a></div></div><div class="public anchor" id="var-should-not.3D.3D"><h3>should-not==</h3><h4 class="type">macro</h4><div class="usage"><code>(should-not== expected actual)</code></div><div class="doc"><pre class="plaintext">Asserts 'non-equivalency'.
When passed collections it will check that they do NOT have the same contents.
For anything else it will assert that clojure.core/== returns false.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L521">view source</a></div></div><div class="public anchor" id="var-should-start-with"><h3>should-start-with</h3><h4 class="type">macro</h4><div class="usage"><code>(should-start-with prefix whole)</code></div><div class="doc"><pre class="plaintext">Assertion of prefix in strings and sequences.

(should-start-with "foo" "foobar")            ; looks for string prefix
(should-start-with [1 2] [1 2 3 4])               ; looks for a subset at start of collection</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L396">view source</a></div></div><div class="public anchor" id="var-should-throw"><h3>should-throw</h3><h4 class="type">macro</h4><div class="usage"><code>(should-throw form)</code><code>(should-throw throwable-type form)</code><code>(should-throw throwable-type predicate form)</code></div><div class="doc"><pre class="plaintext">Asserts that a Throwable is throws by the evaluation of a form.
When an class is passed, it asserts that the thrown Exception is an instance of the class.
There are three options for passing different kinds of predicates:
  - If a string, assert that the message of the Exception is equal to the string.
  - If a regex, asserts that the message of the Exception matches the regex.
  - If a function, assert that calling the function on the Exception returns a truthy value.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L556">view source</a></div></div><div class="public anchor" id="var-should.3C"><h3>should&lt;</h3><h4 class="type">macro</h4><div class="usage"><code>(should&lt; a b)</code></div><div class="doc"><pre class="plaintext">Asserts that the first numeric form is less than the second numeric form, using the built-in &lt; function.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L806">view source</a></div></div><div class="public anchor" id="var-should.3C.3D"><h3>should&lt;=</h3><h4 class="type">macro</h4><div class="usage"><code>(should&lt;= a b)</code></div><div class="doc"><pre class="plaintext">Asserts that the first numeric form is less than or equal to the second numeric form, using the built-in &lt;= function.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L820">view source</a></div></div><div class="public anchor" id="var-should.3D"><h3>should=</h3><h4 class="type">macro</h4><div class="usage"><code>(should= expected-form actual-form)</code><code>(should= expected-form actual-form delta-form)</code></div><div class="doc"><pre class="plaintext">Asserts that two forms evaluate to equal values, with the expected value as the first parameter.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L240">view source</a></div></div><div class="public anchor" id="var-should.3D.3D"><h3>should==</h3><h4 class="type">macro</h4><div class="usage"><code>(should== expected actual)</code></div><div class="doc"><pre class="plaintext">Asserts 'equivalency'.
When passed collections it will check that they have the same contents.
For anything else it will assert that clojure.core/== returns true.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L503">view source</a></div></div><div class="public anchor" id="var-should.3E"><h3>should&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(should&gt; a b)</code></div><div class="doc"><pre class="plaintext">Asserts that the first numeric form is greater than the second numeric form, using the built-in &gt; function.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L813">view source</a></div></div><div class="public anchor" id="var-should.3E.3D"><h3>should&gt;=</h3><h4 class="type">macro</h4><div class="usage"><code>(should&gt;= a b)</code></div><div class="doc"><pre class="plaintext">Asserts that the first numeric form is greater than or equal to the second numeric form, using the built-in &gt;= function.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L827">view source</a></div></div><div class="public anchor" id="var-stub"><h3>stub</h3><h4 class="type">macro</h4><div class="usage"><code>(stub name)</code><code>(stub name options)</code></div><div class="doc"><pre class="plaintext">Creates a stub function.  Each call to the stub will be recorded and can later be looked up using the specified name.

Options:
  :invoke - a function that will be invoked when the stub is invoked.  All the arguments passed to the stub will
    be passed to the :invoke value and its return value returned by the stub.
  :return - a value that will be returned by the stub.  This overrides the result of the :invoke value, if specified.
  :throw - an exception that will be thrown by the stub.</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L638">view source</a></div></div><div class="public anchor" id="var-tags"><h3>tags</h3><h4 class="type">macro</h4><div class="usage"><code>(tags &amp; values)</code></div><div class="doc"><pre class="plaintext">Add tags to the containing context.  All values passed will be converted into keywords.  Contexts can be filtered
at runtime by their tags.

(tags :one :two)</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L622">view source</a></div></div><div class="public anchor" id="var-with"><h3>with</h3><h4 class="type">macro</h4><div class="usage"><code>(with name &amp; body)</code></div><div class="doc"><pre class="plaintext">Declares a reference-able symbol that will be lazily evaluated once per characteristic of the containing
describe scope.  The body may contain any forms, the last of which will be the value of the dereferenced symbol.

(with meaning 42)
(it "knows the meaning of life" (should= @meaning (the-meaning-of :life)))</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L170">view source</a></div></div><div class="public anchor" id="var-with.21"><h3>with!</h3><h4 class="type">macro</h4><div class="usage"><code>(with! name &amp; body)</code></div><div class="doc"><pre class="plaintext">Declares a reference-able symbol that will be evaluated immediately and reset once per characteristic of the containing
describe scope.  The body may contain any forms, the last of which will be the value of the dereferenced symbol.

(def my-num (atom 0))
(with! my-with! (swap! my-num inc))
(it "increments my-num before being accessed" (should= 1 @my-num) (should= 2 @my-with!))</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L179">view source</a></div></div><div class="public anchor" id="var-with-all"><h3>with-all</h3><h4 class="type">macro</h4><div class="usage"><code>(with-all name &amp; body)</code></div><div class="doc"><pre class="plaintext">Declares a reference-able symbol that will be lazily evaluated once per context. The body may contain any forms,
 the last of which will be the value of the dereferenced symbol.

(with-all meaning 42)
(it "knows the meaning of life" (should= @meaning (the-meaning-of :life)))</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L189">view source</a></div></div><div class="public anchor" id="var-with-all.21"><h3>with-all!</h3><h4 class="type">macro</h4><div class="usage"><code>(with-all! name &amp; body)</code></div><div class="doc"><pre class="plaintext">Declares a reference-able symbol that will be immediately evaluated once per context. The body may contain any forms,
 the last of which will be the value of the dereferenced symbol.

(def my-num (atom 0))
(with-all! my-with-all! (swap! my-num inc))
(it "increments my-num before being accessed"
  (should= 1 @my-num)
  (should= 2 @my-with!))
(it "only increments my-num once per context"
  (should= 1 @my-num)
  (should= 2 @my-with!))</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L198">view source</a></div></div><div class="public anchor" id="var-with-stubs"><h3>with-stubs</h3><h4 class="type">macro</h4><div class="usage"><code>(with-stubs)</code></div><div class="doc"><pre class="plaintext">Add this to describe/context blocks that use stubs.  It will setup a clean recording environment.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L631">view source</a></div></div><div class="public anchor" id="var-xit"><h3>xit</h3><h4 class="type">macro</h4><div class="usage"><code>(xit name &amp; body)</code></div><div class="doc"><pre class="plaintext">Syntactic shortcut to make the characteristic pending.
</pre></div><div class="src-link"><a href="https://github.com/slagyr/speclj/blob/3.4.2/src/speclj/core.cljc#L62">view source</a></div></div></div></body></html>